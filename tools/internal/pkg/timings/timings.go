//
// Copyright (c) 2020, NVIDIA CORPORATION. All rights reserved.
//
// See LICENSE.txt for license information
//

package timings

import (
	"bufio"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strconv"
	"strings"

	"github.com/gvallee/alltoallv_profiling/tools/internal/pkg/grouping"
	"github.com/gvallee/alltoallv_profiling/tools/internal/pkg/maps"
	"github.com/gvallee/alltoallv_profiling/tools/internal/pkg/progress"
)

const (
	CallDelimiter        = "Alltoallv call #"
	lateArrivalDelimiter = "# Late arrival timings"
	executionDelimiter   = "# Execution times of Alltoallv function"

	// FilePrefix is the prefix used for former default timings files
	SingleProfileFilePrefix = "timings."

	// AlltoallFilePrefix is the prefix used when the profiler is gathering execution times
	AlltoallFilePrefix = "a2a-timings"

	// LateArrivalFilePrefix is the prefix used when the rofiler is gathering late arrival times
	LateArrivalFilePrefix = "late-arrivals-timings"
)

const (
	// separateTimingsFiles represents the case where the profiler generates two file: one for all a2a execution time and one for all late arrival timings
	separateTimingsFiles = iota

	// singleProfileFile identifies the old format where the profiler generated a single file with all the timings in it
	singleProfileFile
)

type Stats struct {
	Timings  string
	Data     []float64
	Max      float64
	Min      float64
	Mean     float64
	Grouping *grouping.Engine
}

type CallTimings struct {
	ExecutionTimings    Stats
	LateArrivalsTimings Stats
}

func saveLine(file *os.File, callNum string, line string) error {
	if strings.HasPrefix(line, "Rank") {
		tokens := strings.Split(line, ": ")
		line = callNum + "\t" + tokens[1]
	}
	_, err := file.WriteString(line)
	return err
}

func extractTimingData(reader *bufio.Reader, laf *os.File, a2af *os.File) error {
	extractingLateArrivalTimings := false
	extractingAlltoallvExecutionTimings := false
	currentCall := ""

	for {
		line, readerErr := reader.ReadString('\n')
		if readerErr != nil && readerErr != io.EOF {
			return readerErr
		}

		if strings.HasPrefix(line, CallDelimiter) {
			currentCall = strings.TrimRight(line, "\n")
			currentCall = strings.TrimLeft(currentCall, CallDelimiter)
			continue
		}

		if strings.HasPrefix(line, lateArrivalDelimiter) {
			extractingLateArrivalTimings = true
			extractingAlltoallvExecutionTimings = false
			continue
		}

		if strings.HasPrefix(line, executionDelimiter) {
			extractingLateArrivalTimings = false
			extractingAlltoallvExecutionTimings = true
			continue
		}

		if extractingAlltoallvExecutionTimings {
			err := saveLine(a2af, currentCall, line)
			if err != nil {
				return err
			}
		}

		if extractingLateArrivalTimings {
			err := saveLine(laf, currentCall, line)
			if err != nil {
				return err
			}
		}

		if readerErr == io.EOF {
			break
		}
	}
	return nil
}

func ExtractTimings(inputFile string, lateArrivalFilename string, a2aFilename string) error {
	inputf, err := os.Open(inputFile)
	if err != nil {
		return err
	}
	defer inputf.Close()
	reader := bufio.NewReader(inputf)

	laf, err := os.OpenFile(lateArrivalFilename, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0755)
	if err != nil {
		return err
	}
	defer laf.Close()

	a2af, err := os.OpenFile(a2aFilename, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0755)
	if err != nil {
		return err
	}
	defer a2af.Close()

	return extractTimingData(reader, laf, a2af)
}

func getAlltoallvTimingsFilePath(dir string, jobid int, rank int) string {
	return filepath.Join(dir, fmt.Sprintf("alltoallv_timings.job%d.rank%d.dat", jobid, rank))
}

func getLateArrivalTimingsFilePath(dir string, jobid int, rank int) string {
	return filepath.Join(dir, fmt.Sprintf("late_arrival_timings.job%d.rank%d.dat", jobid, rank))
}

// PreprocessRawDataFile handlees the file generated by the profiler when it uses the format where all the data
// is generated in a single file
func PreprocessRawDataFile(filePath string, outputDir string, a2aTimes map[int]map[int]map[int]float64, lateArrivalTimes map[int]map[int]map[int]float64) error {
	lateArrivalFilename := strings.ReplaceAll(filepath.Base(filePath), "timings", "late_arrival_timings")
	lateArrivalFilename = strings.ReplaceAll(lateArrivalFilename, ".md", ".dat")
	a2aFilename := strings.ReplaceAll(filepath.Base(filePath), "timings", "alltoallv_timings")
	a2aFilename = strings.ReplaceAll(a2aFilename, ".md", ".dat")
	if outputDir != "" {
		lateArrivalFilename = filepath.Join(outputDir, lateArrivalFilename)
		a2aFilename = filepath.Join(outputDir, a2aFilename)
	}

	err := ExtractTimings(filePath, lateArrivalFilename, a2aFilename)
	if err != nil {
		return err
	}

	return nil
}

func getCallDataFromFile(path string, numCall int) (Stats, error) {
	var t Stats
	t.Max = 0.0
	t.Min = -1.0
	t.Timings = ""
	sum := 0.0
	num := 0.0

	f, err := os.Open(path)
	if err != nil {
		return t, err
	}
	defer f.Close()

	reader := bufio.NewReader(f)

	for {
		line, readerr := reader.ReadString('\n')
		if readerr != nil && readerr != io.EOF {
			return t, readerr
		}
		if line == "" && readerr == io.EOF {
			break
		}

		line = strings.TrimRight(line, "\n")
		if line == "" {
			continue
		}

		// We split the line, the first element is the call number and the second element the actual timing
		tokens := strings.Split(line, "\t")
		if len(tokens) != 2 {
			return t, fmt.Errorf("invalid format: %s", line)
		}
		callID, err := strconv.Atoi(tokens[0])
		if err != nil {
			return t, err
		}

		if callID < numCall {
			continue
		}

		if callID == numCall {
			timing, err := strconv.ParseFloat(strings.TrimRight(tokens[1], "\n"), 64)
			if err != nil {
				return t, err
			}
			t.Data = append(t.Data, timing)
			sum += timing

			if t.Min == -1.0 || t.Min > timing {
				t.Min = timing
			}
			if t.Max < timing {
				t.Max = timing
			}

			t.Timings = t.Timings + tokens[1] + "\n"
			num++
		}

		if callID > numCall {
			break
		}
	}

	t.Mean = sum / num
	err = t.groupTimings()
	if err != nil {
		return t, err
	}

	return t, nil
}

func GetCallData(dir string, jobid int, rank int, numCall int) (CallTimings, error) {
	var t CallTimings
	var err error

	a2aTimingsFile := getAlltoallvTimingsFilePath(dir, jobid, rank)
	lateArrivalTimingsFile := getLateArrivalTimingsFilePath(dir, jobid, rank)

	log.Printf("-> Getting execution timings from %s\n", a2aTimingsFile)
	t.ExecutionTimings, err = getCallDataFromFile(a2aTimingsFile, numCall)
	if err != nil {
		return t, err
	}
	log.Printf("-> Getting late arrival timings from %s\n", lateArrivalTimingsFile)
	t.LateArrivalsTimings, err = getCallDataFromFile(lateArrivalTimingsFile, numCall)
	if err != nil {
		return t, err
	}

	return t, nil
}

func (s *Stats) groupTimings() error {
	if s.Grouping == nil {
		s.Grouping = grouping.Init()
	}

	var ints []int
	for _, d := range s.Data {
		ints = append(ints, int(d))
	}

	for i := 0; i < len(ints); i++ {
		err := s.Grouping.AddDatapoint(i, ints)
		if err != nil {
			return err
		}
	}

	gps, err := s.Grouping.GetGroups()
	if err != nil {
		return err
	}
	fmt.Printf("Number of groups: %d", len(gps))

	return nil
}

func detectTimingFileFormat(files []string) int {
	// todo: to the clever thing here
	// first we should check the latest format
	// second we have one file per call and per timing type (a2a, late arrivals)
	// then if we have the preprocessed data based on the old format
	// last the single file with all timings in it from profiler

	return separateTimingsFiles
}

func getLeadRankFromFilename(filename string) (int, error) {
	idx := strings.LastIndex(filename, "rank")
	rankStr := filename[idx+4:]
	rankStr = strings.TrimRight(rankStr, ".md")
	rank, err := strconv.Atoi(rankStr)
	if err != nil {
		return -1, err
	}
	return rank, nil
}

func extractTimingsFromSeparateTimingFile(file string, totalExecutionTime map[int]float64, callsMaps map[int]maps.CallsDataT, commData map[int]map[int]map[int]float64) error {
	f, err := os.Open(file)
	if err != nil {
		return err
	}
	defer f.Close()

	leadRank, err := getLeadRankFromFilename(filepath.Base(file))
	if err != nil {
		return err
	}
	commData[leadRank] = map[int]map[int]float64{}

	reader := bufio.NewReader(f)

	for {
		line, readerr := reader.ReadString('\n')
		if readerr != nil && readerr == io.EOF {
			break
		}
		if readerr != nil && readerr != io.EOF {
			return err
		}

		if !strings.HasPrefix(line, "Alltoallv call #") {
			return fmt.Errorf("invalid file format (%s is unexpected)", line)
		}
		line = strings.TrimRight(line, "\n")
		line = strings.TrimLeft(line, "Alltoallv call #")
		callID, err := strconv.Atoi(line)
		if err != nil {
			return err
		}

		commData[leadRank][callID] = make(map[int]float64)

		for {
			line, readerr := reader.ReadString('\n')
			if readerr != nil {
				return err
			}
			line = strings.TrimRight(line, "\n")
			if line == "" {
				// We reach the end of the block
				break
			}
			tokens := strings.Split(line, ": ")
			if len(tokens) != 2 {
				return fmt.Errorf("Invalid line format: %s", line)
			}
			value, err := strconv.ParseFloat(tokens[1], 64)
			if err != nil {
				return err
			}
			commRank, err := strconv.Atoi(strings.TrimLeft(tokens[0], "Rank "))
			if err != nil {
				return err
			}
			// Convert commRank to rank on CommWorld
			commWorldRank := callsMaps[leadRank].RanksMap[callID][commRank]
			commData[leadRank][callID][commWorldRank] = value
			totalExecutionTime[commWorldRank] += value
		}
	}

	return nil
}

func analyzeTimingsFiles(dir string, files []string, callsMaps map[int]maps.CallsDataT, totalExecutionTimes map[int]float64, totalLateArrivalTimes map[int]float64) (map[int]map[int]map[int]float64, map[int]map[int]map[int]float64, error) {
	// comm-centric maps where the keys are: leadRank, callID and world rank; the value an array of time
	a2aTimes := map[int]map[int]map[int]float64{}
	lateArrivalTimes := map[int]map[int]map[int]float64{}

	format := detectTimingFileFormat(files)

	switch format {
	case singleProfileFile:
		// Do we need to pre-process the data or is it already available as is
		bar := progress.NewBar(len(files), "Pre-processing timings files")
		defer progress.EndBar(bar)
		for _, file := range files {
			bar.Increment(1)
			// The output directory is where the data is, this tool keeps all the data together
			if strings.HasPrefix(file, SingleProfileFilePrefix) {
				err := PreprocessRawDataFile(file, dir, a2aTimes, lateArrivalTimes)
				if err != nil {
					return nil, nil, err
				}
			}
		}

	case separateTimingsFiles:
		for _, file := range files {
			if strings.HasPrefix(filepath.Base(file), AlltoallFilePrefix) {
				err := extractTimingsFromSeparateTimingFile(file, totalExecutionTimes, callsMaps, a2aTimes)
				if err != nil {
					return nil, nil, err
				}
			}

			if strings.HasPrefix(filepath.Base(file), LateArrivalFilePrefix) {
				err := extractTimingsFromSeparateTimingFile(file, totalLateArrivalTimes, callsMaps, lateArrivalTimes)
				if err != nil {
					return nil, nil, err
				}
			}
		}
	default:
		return nil, nil, fmt.Errorf("unknown format: %d", format)
	}

	return a2aTimes, lateArrivalTimes, nil
}

// HandleTimingFiles is a high-level function that will find all the timings related files
// generated by the profiler and analyze them
func HandleTimingFiles(dir string, totalNumCalls int, callsMaps map[int]maps.CallsDataT) (map[int]map[int]map[int]float64, map[int]map[int]map[int]float64, map[int]float64, map[int]float64, error) {
	// Detect all timings file, regardless of their format
	f, err := ioutil.ReadDir(dir)
	if err != nil {
		return nil, nil, nil, nil, err
	}

	totalExecutionTimes := make(map[int]float64)
	totalLateArrivalTimes := make(map[int]float64)

	var files []string
	for _, file := range f {
		if strings.HasPrefix(file.Name(), AlltoallFilePrefix) {
			files = append(files, filepath.Join(dir, file.Name()))
		}
		if strings.HasPrefix(file.Name(), LateArrivalFilePrefix) {
			files = append(files, filepath.Join(dir, file.Name()))
		}
		if strings.HasPrefix(file.Name(), SingleProfileFilePrefix) {
			files = append(files, filepath.Join(dir, file.Name()))
		}
	}

	// Analyze all the files we found
	a2aExecutionTimes, lateArrivalTimes, err := analyzeTimingsFiles(dir, files, callsMaps, totalExecutionTimes, totalLateArrivalTimes)
	if err != nil {
		return nil, nil, nil, nil, err
	}

	return a2aExecutionTimes, lateArrivalTimes, totalExecutionTimes, totalLateArrivalTimes, nil
}
